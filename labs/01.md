# Lab 1: Node.js Application with OpenTelemetry & SigNoz

This lab provides a complete Node.js application with OpenTelemetry instrumentation to practice monitoring with SigNoz.

## Lab Overview

- **Sample Application**: E-commerce API with user registrations, orders, and payments
- **OpenTelemetry**: Automatic and manual instrumentation for traces and metrics
- **SigNoz**: APM and observability platform
- **Docker Compose**: Easy setup with single command

## Step 1: Project Structure

Create the following directory structure:

```
nodejs-lab/
├── app/
│   ├── src/
│   │   ├── server.js
│   │   ├── routes/
│   │   │   ├── users.js
│   │   │   ├── orders.js
│   │   │   └── payments.js
│   │   └── middleware/
│   │       └── tracing.js
│   ├── tracing.js
│   ├── metrics.js
│   ├── package.json
│   └── Dockerfile
├── docker-compose.yml
└── README.md
```

## Step 2: Create package.json

**app/package.json:**

```json
{
  "name": "nodejs-signoz-lab",
  "version": "1.0.0",
  "description": "Node.js app with OpenTelemetry instrumentation",
  "main": "src/server.js",
  "scripts": {
    "start": "node --require ./tracing.js src/server.js",
    "dev": "nodemon --require ./tracing.js src/server.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "@opentelemetry/api": "^1.7.0",
    "@opentelemetry/sdk-node": "^0.45.0",
    "@opentelemetry/auto-instrumentations-node": "^0.40.0",
    "@opentelemetry/exporter-otlp-http": "^0.45.0",
    "@opentelemetry/exporter-metrics-otlp-http": "^0.45.0",
    "@opentelemetry/sdk-metrics": "^1.18.0",
    "@opentelemetry/resources": "^1.18.0",
    "@opentelemetry/semantic-conventions": "^1.18.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}
```

## Step 3: Create Tracing Configuration

**app/tracing.js:**

```javascript
const { NodeSDK } = require('@opentelemetry/sdk-node');
const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');

// Load environment variables
require('dotenv').config();

// Configure resource
const resource = new Resource({
  [SemanticResourceAttributes.SERVICE_NAME]: 'ecommerce-api',
  [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',
  [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV || 'development',
});

// Create SDK
const sdk = new NodeSDK({
  resource,
  traceExporter: new OTLPTraceExporter({
    url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318/v1/traces',
  }),
  instrumentations: [getNodeAutoInstrumentations()],
});

// Initialize the SDK
sdk.start();

console.log('OpenTelemetry SDK initialized');

// Gracefully shutdown the SDK
process.on('SIGTERM', () => {
  sdk.shutdown()
    .then(() => console.log('Tracing terminated'))
    .catch((error) => console.log('Error terminating tracing', error))
    .finally(() => process.exit(0));
});
```

## Step 4: Create Metrics Configuration

**app/metrics.js:**

```javascript
const opentelemetry = require('@opentelemetry/api');
const { MeterProvider } = require('@opentelemetry/sdk-metrics');
const { PeriodicExportingMetricReader } = require('@opentelemetry/sdk-metrics');
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');
const { OTLPMetricExporter } = require('@opentelemetry/exporter-metrics-otlp-http');

// Load environment variables
require('dotenv').config();

// Configure resource
const resource = new Resource({
  [SemanticResourceAttributes.SERVICE_NAME]: 'ecommerce-api',
  [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',
});

// Configure metric exporter
const metricExporter = new OTLPMetricExporter({
  url: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4318/v1/metrics',
});

// Configure metric reader
const metricReader = new PeriodicExportingMetricReader({
  exporter: metricExporter,
  exportIntervalMillis: 10000, // Export every 10 seconds
});

// Setup meter provider
const meterProvider = new MeterProvider({
  resource,
  readers: [metricReader],
});

// Set as global meter provider
opentelemetry.metrics.setGlobalMeterProvider(meterProvider);

// Get a meter instance
const meter = opentelemetry.metrics.getMeter('ecommerce-app', '1.0.0');

// Define custom metrics
const metrics = {
  orderCounter: meter.createCounter('orders.total', {
    description: 'Total number of orders placed',
  }),
  
  orderValueHistogram: meter.createHistogram('order.value', {
    description: 'Value of orders in USD',
    unit: 'USD',
  }),
  
  paymentDuration: meter.createHistogram('payment.processing.duration', {
    description: 'Time taken to process payment in milliseconds',
    unit: 'ms',
  }),
  
  userRegistrationCounter: meter.createCounter('users.registrations.total', {
    description: 'Total number of user registrations',
  }),
  
  failedPaymentCounter: meter.createCounter('payments.failed.total', {
    description: 'Total number of failed payments',
  }),
};

module.exports = metrics;
```

## Step 5: Create Main Server

**app/src/server.js:**

```javascript
const express = require('express');
const userRoutes = require('./routes/users');
const orderRoutes = require('./routes/orders');
const paymentRoutes = require('./routes/payments');

const app = express();
app.use(express.json());

// Routes
app.use('/api/users', userRoutes);
app.use('/api/orders', orderRoutes);
app.use('/api/payments', paymentRoutes);

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## Step 6: Create User Routes

**app/src/routes/users.js:**

```javascript
const express = require('express');
const router = express.Router();
const { trace } = require('@opentelemetry/api');
const metrics = require('../../metrics');

const tracer = trace.getTracer('user-service', '1.0.0');

// Simulated user database
let users = [];
let userIdCounter = 1;

// Register new user
router.post('/register', (req, res) => {
  const span = tracer.startSpan('register_user');
  
  try {
    span.setAttributes({
      'user.email': req.body.email,
      'user.method': req.body.method || 'email',
    });
    
    const user = {
      id: userIdCounter++,
      username: req.body.username,
      email: req.body.email,
      createdAt: new Date(),
    };
    
    users.push(user);
    
    // Increment metric
    metrics.userRegistrationCounter.add(1, {
      method: req.body.method || 'email',
    });
    
    span.setStatus({ code: 0 });
    res.status(201).json({ success: true, user });
  } catch (error) {
    span.recordException(error);
    span.setStatus({ code: 1, message: error.message });
    res.status(500).json({ error: error.message });
  } finally {
    span.end();
  }
});

// Get all users
router.get('/', (req, res) => {
  const span = tracer.startSpan('get_users');
  
  try {
    span.setAttribute('users.count', users.length);
    span.setStatus({ code: 0 });
    res.json({ users, count: users.length });
  } catch (error) {
    span.recordException(error);
    span.setStatus({ code: 1, message: error.message });
    res.status(500).json({ error: error.message });
  } finally {
    span.end();
  }
});

// Get user by ID
router.get('/:id', (req, res) => {
  const span = tracer.startSpan('get_user_by_id');
  
  try {
    const user = users.find(u => u.id === parseInt(req.params.id));
    
    if (user) {
      span.setAttribute('user.id', user.id);
      span.setStatus({ code: 0 });
      res.json(user);
    } else {
      span.setStatus({ code: 1, message: 'User not found' });
      res.status(404).json({ error: 'User not found' });
    }
  } catch (error) {
    span.recordException(error);
    span.setStatus({ code: 1, message: error.message });
    res.status(500).json({ error: error.message });
  } finally {
    span.end();
  }
});

module.exports = router;
```

## Step 7: Create Order Routes

**app/src/routes/orders.js:**

```javascript
const express = require('express');
const router = express.Router();
const { trace } = require('@opentelemetry/api');
const metrics = require('../../metrics');

const tracer = trace.getTracer('order-service', '1.0.0');

// Simulated order database
let orders = [];
let orderIdCounter = 1;

// Create new order
router.post('/', async (req, res) => {
  const span = tracer.startSpan('create_order');
  
  try {
    const { userId, items, total } = req.body;
    
    span.setAttributes({
      'order.user_id': userId,
      'order.total': total,
      'order.items_count': items.length,
    });
    
    // Simulate some processing time
    await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
    
    const order = {
      id: orderIdCounter++,
      userId,
      items,
      total,
      status: 'pending',
      createdAt: new Date(),
    };
    
    orders.push(order);
    
    // Increment counter
    metrics.orderCounter.add(1, {
      status: order.status,
    });
    
    // Record order value
    metrics.orderValueHistogram.record(total, {
      currency: 'USD',
    });
    
    span.addEvent('order_created', {
      order_id: order.id,
      total: order.total,
    });
    
    span.setStatus({ code: 0 });
    res.status(201).json({ success: true, order });
  } catch (error) {
    span.recordException(error);
    span.setStatus({ code: 1, message: error.message });
    res.status(500).json({ error: error.message });
  } finally {
    span.end();
  }
});

// Get all orders
router.get('/', (req, res) => {
  const span = tracer.startSpan('get_orders');
  
  try {
    span.setAttribute('orders.count', orders.length);
    span.setStatus({ code: 0 });
    res.json({ orders, count: orders.length });
  } catch (error) {
    span.recordException(error);
    span.setStatus({ code: 1, message: error.message });
    res.status(500).json({ error: error.message });
  } finally {
    span.end();
  }
});

// Get order by ID
router.get('/:id', (req, res) => {
  const span = tracer.startSpan('get_order_by_id');
  
  try {
    const order = orders.find(o => o.id === parseInt(req.params.id));
    
    if (order) {
      span.setAttributes({
        'order.id': order.id,
        'order.status': order.status,
        'order.total': order.total,
      });
      span.setStatus({ code: 0 });
      res.json(order);
    } else {
      span.setStatus({ code: 1, message: 'Order not found' });
      res.status(404).json({ error: 'Order not found' });
    }
  } catch (error) {
    span.recordException(error);
    span.setStatus({ code: 1, message: error.message });
    res.status(500).json({ error: error.message });
  } finally {
    span.end();
  }
});

module.exports = router;
```

## Step 8: Create Payment Routes

**app/src/routes/payments.js:**

```javascript
const express = require('express');
const router = express.Router();
const { trace } = require('@opentelemetry/api');
const metrics = require('../../metrics');

const tracer = trace.getTracer('payment-service', '1.0.0');

// Process payment
router.post('/process', async (req, res) => {
  const startTime = Date.now();
  const span = tracer.startSpan('process_payment');
  
  try {
    const { orderId, amount, paymentMethod } = req.body;
    
    span.setAttributes({
      'payment.order_id': orderId,
      'payment.amount': amount,
      'payment.method': paymentMethod,
    });
    
    // Simulate payment processing time
    const processingTime = Math.random() * 500 + 200; // 200-700ms
    await new Promise(resolve => setTimeout(resolve, processingTime));
    
    // Simulate occasional failures (10% failure rate)
    const isSuccess = Math.random() > 0.1;
    
    const actualDuration = Date.now() - startTime;
    
    if (isSuccess) {
      span.addEvent('payment_success', {
        transaction_id: `TXN-${Date.now()}`,
      });
      
      metrics.paymentDuration.record(actualDuration, {
        status: 'success',
        payment_method: paymentMethod,
      });
      
      span.setStatus({ code: 0 });
      res.json({
        success: true,
        transactionId: `TXN-${Date.now()}`,
        amount,
        status: 'completed',
      });
    } else {
      // Increment failed payment counter
      metrics.failedPaymentCounter.add(1, {
        reason: 'payment_gateway_error',
        payment_method: paymentMethod,
      });
      
      metrics.paymentDuration.record(actualDuration, {
        status: 'failed',
        payment_method: paymentMethod,
      });
      
      span.addEvent('payment_failed', {
        reason: 'payment_gateway_error',
      });
      
      span.setStatus({ code: 1, message: 'Payment failed' });
      res.status(500).json({ error: 'Payment processing failed' });
    }
  } catch (error) {
    const actualDuration = Date.now() - startTime;
    metrics.paymentDuration.record(actualDuration, {
      status: 'error',
    });
    
    span.recordException(error);
    span.setStatus({ code: 1, message: error.message });
    res.status(500).json({ error: error.message });
  } finally {
    span.end();
  }
});

module.exports = router;
```

## Step 9: Create Dockerfile

**app/Dockerfile:**

```dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application code
COPY . .

# Expose port
EXPOSE 3000

# Start application with OpenTelemetry
CMD ["node", "--require", "./tracing.js", "src/server.js"]
```

## Step 10: Create Docker Compose

**docker-compose.yml:**

```yaml
version: '3.8'

services:
  app:
    build: ./app
    container_name: ecommerce-api
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - OTEL_EXPORTER_OTLP_ENDPOINT=http://signoz-otlp:4318
      - OTEL_LOG_LEVEL=info
    depends_on:
      signoz-otlp:
        condition: service_healthy
    networks:
      - signoz

  signoz-otlp:
    image: signoz/signoz-otelcol:0.99.1
    container_name: signoz-otlp
    ports:
      - "4317:4317"   # OTLP gRPC receiver
      - "4318:4318"   # OTLP HTTP receiver
    command: ["--config=/etc/otel-collector-config.yaml"]
    volumes:
      - ./otel-collector-config.yaml:/etc/otel-collector-config.yaml
    environment:
      - SIGNOZ_ENABLED=true
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:13133"]
      interval: 10s
      timeout: 3s
      retries: 3
    networks:
      - signoz

  signoz:
    image: signoz/signoz:0.99.1
    container_name: signoz
    ports:
      - "3301:3301"   # SigNoz UI
    depends_on:
      signoz-otlp:
        condition: service_healthy
    environment:
      - OTEL_COLLECTOR_SVC=http://signoz-otlp:4317
    networks:
      - signoz

networks:
  signoz:
    driver: bridge
```

## Step 11: Create OpenTelemetry Collector Config

**otel-collector-config.yaml:**

```yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318

processors:
  batch:
    timeout: 1s
    send_batch_size: 1024

exporters:
  signoz:
    endpoint: "http://signoz:3301/api/v1/otlp"

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [signoz]
    metrics:
      receivers: [otlp]
      processors: [batch]
      exporters: [signoz]
    logs:
      receivers: [otlp]
      processors: [batch]
      exporters: [signoz]
```

## Step 12: Create .env file

**app/.env:**

```env
NODE_ENV=development
PORT=3000
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4318
OTEL_LOG_LEVEL=info
```

## Step 13: Running the Lab

### Install Dependencies Locally (Optional)

```bash
cd app
npm install
```

### Run with Docker Compose

```bash
# Start all services
docker-compose up --build

# In another terminal, send test requests
curl http://localhost:3000/health

# Register a user
curl -X POST http://localhost:3000/api/users/register \
  -H "Content-Type: application/json" \
  -d '{"username":"john","email":"john@example.com"}'

# Create an order
curl -X POST http://localhost:3000/api/orders \
  -H "Content-Type: application/json" \
  -d '{"userId":1,"items":["item1","item2"],"total":99.99}'

# Process payment
curl -X POST http://localhost:3000/api/payments/process \
  -H "Content-Type: application/json" \
  -d '{"orderId":1,"amount":99.99,"paymentMethod":"credit_card"}'
```

### Access Services

- **Application**: http://localhost:3000
- **SigNoz UI**: http://localhost:3301

## Step 14: View Traces in SigNoz

1. Open http://localhost:3301
2. Go to "Traces" tab
3. You should see traces for:
   - User registrations
   - Order creation
   - Payment processing
4. Click on any trace to see the span waterfall

## Step 15: View Metrics in SigNoz

1. Go to "Dashboards" in SigNoz
2. Create custom dashboard with panels for:
   - `orders.total` - Order count
   - `order.value` - Order value histogram
   - `payment.processing.duration` - Payment processing time
   - `users.registrations.total` - User registrations
   - `payments.failed.total` - Failed payments

## Next Steps

- Add more endpoints and functionality
- Experiment with different span attributes
- Create alerts based on custom metrics
- Add database integration
- Implement distributed tracing with multiple services
