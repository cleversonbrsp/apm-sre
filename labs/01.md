A **complete lab environment** to practice observability concepts using **Docker, SigNoz, Grafana, Prometheus, etc.** is a great way to get hands-on experience. Here's how you can set it up with a **simple app** that simulates requests of various types (e.g., `GET`, `POST`, `PUT`, etc.).

### Lab Overview

1. **Simple App**: A Node.js app to simulate HTTP requests of various types.
2. **Prometheus**: Collects and stores metrics from the app.
3. **Grafana**: Displays the data collected by Prometheus.
4. **SigNoz**: Provides APM (Application Performance Monitoring) to trace and monitor requests.

### Step-by-Step Guide

#### 1. Set up a simple Node.js app to simulate requests

We'll use a basic Node.js app that simulates different HTTP request types and some random delays to mimic realistic behavior. This app will generate metrics for Prometheus and traces for SigNoz.

**Create `app.js`:**

```javascript
const express = require('express');
const promClient = require('prom-client');
const { initTracer } = require('opentelemetry-api');
const { ZipkinExporter } = require('@opentelemetry/exporter-zipkin');
const { SimpleSpanProcessor } = require('@opentelemetry/sdk-trace-base');

const app = express();
const port = 3000;

// Prometheus Metrics Setup
const register = new promClient.Registry();
const httpRequestsTotal = new promClient.Counter({
  name: 'http_requests_total',
  help: 'Total HTTP requests made',
  labelNames: ['method', 'code'],
});
register.registerMetric(httpRequestsTotal);

// SigNoz Tracing Setup
const tracer = initTracer(new ZipkinExporter({
  url: 'http://localhost:9411/api/v2/spans',
}), {});

// Simple Routes to Simulate Different Request Types
app.get('/', (req, res) => {
  httpRequestsTotal.inc({ method: 'GET', code: '200' });
  res.send('GET Request');
});

app.post('/', (req, res) => {
  httpRequestsTotal.inc({ method: 'POST', code: '200' });
  res.send('POST Request');
});

app.put('/', (req, res) => {
  httpRequestsTotal.inc({ method: 'PUT', code: '200' });
  res.send('PUT Request');
});

// Metrics Endpoint for Prometheus
app.get('/metrics', (req, res) => {
  res.set('Content-Type', register.contentType);
  res.end(register.metrics());
});

// Simulate a random delay
function simulateDelay() {
  return new Promise((resolve) => setTimeout(resolve, Math.random() * 2000));
}

// Start the app
app.listen(port, () => {
  console.log(`App running on http://localhost:${port}`);
});
```

#### 2. Dockerize the Application

Create a `Dockerfile` to containerize your app.

**Dockerfile:**

```dockerfile
# Use Node.js official image
FROM node:16

# Create and set the working directory
WORKDIR /usr/src/app

# Copy package.json and install dependencies
COPY package*.json ./
RUN npm install

# Copy the rest of the application code
COPY . .

# Expose port
EXPOSE 3000

# Start the application
CMD ["node", "app.js"]
```

#### 3. Create a `docker-compose.yml` to orchestrate services

You will use **Docker Compose** to spin up multiple services: your app, Prometheus, Grafana, and SigNoz.

```yaml
version: '3.7'

services:
  # Node.js app
  app:
    build: .
    ports:
      - "3000:3000"
    networks:
      - monitoring
    environment:
      - "SIGNOZ_ENABLED=true"

  # Prometheus
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
    networks:
      - monitoring

  # Grafana
  grafana:
    image: grafana/grafana:latest
    container_name: grafana
    ports:
      - "3001:3000"
    networks:
      - monitoring
    environment:
      GF_SECURITY_ADMIN_PASSWORD: "admin"
    depends_on:
      - prometheus

  # SigNoz (APM)
  signoza:
    image: signoz/signoz:latest
    container_name: signoza
    ports:
      - "3301:3301"
      - "4317:4317"
    networks:
      - monitoring
    environment:
      SIGNOZ_UI_PORT: "3301"
      SIGNOZ_APM_PORT: "4317"
    depends_on:
      - app

networks:
  monitoring:
    driver: bridge
```

#### 4. Create `prometheus.yml` configuration file

Prometheus needs a configuration file to scrape the `/metrics` endpoint from your app.

**prometheus.yml**:

```yaml
global:
  scrape_interval: 5s

scrape_configs:
  - job_name: 'node_app'
    static_configs:
      - targets: ['app:3000']
```

#### 5. Launch the services

In the terminal, run the following command to bring up the Docker containers:

```bash
docker-compose up --build
```

This will start your app, Prometheus, Grafana, and SigNoz.

#### 6. Accessing the Services

* **Node.js App**: Open [http://localhost:3000](http://localhost:3000) to hit the `/` route (GET request).
* **Prometheus**: Open [http://localhost:9090](http://localhost:9090) to access Prometheus Web UI.
* **Grafana**: Open [http://localhost:3001](http://localhost:3001) and login with the default credentials (`admin/admin`), and configure it to connect to Prometheus as a data source.
* **SigNoz**: Open [http://localhost:3301](http://localhost:3301) to access the SigNoz UI for APM.

#### 7. Visualizing Data in Grafana

1. Go to **Grafana** ([http://localhost:3001](http://localhost:3001)).
2. Add **Prometheus** as a data source (URL: `http://prometheus:9090`).
3. Create a new **Dashboard** in Grafana and add panels for metrics like:

   * **Request rate** (e.g., `http_requests_total`).
   * **Response latency** (e.g., `http_request_duration_seconds`).
   * **Error rate** (e.g., `http_requests_total{code="5xx"}`).

#### 8. Viewing Traces in SigNoz

1. After some traffic to your app (hit endpoints `/`, `/metrics`), go to **SigNoz UI**.
2. You should see traces for requests sent from your app, showing latency, status codes, and performance across different services (if you scale your app).

### Final Thoughts

* **Prometheus** will collect metrics like request rate, latency, and error rates.
* **Grafana** will allow you to visualize these metrics and monitor your app in real time.
* **SigNoz** provides end-to-end tracing to visualize how each request flows through your system, helping you understand performance bottlenecks.

This setup will allow you to practice observability and performance monitoring concepts while gaining hands-on experience with popular observability tools. You can expand this lab by adding more services, experimenting with complex scenarios, and even integrating alerting mechanisms!
